/*
 * Find the sum of perimeters of all almost-equilateral triangles with perimeters under N and integral sides and areas
 */

#include <stdio.h>
#include <stdlib.h>
#include "math_utils.h"

static long get_perimeter (int, int);
static int get_m (int, int, int);

int main (int argc, char ** argv) {
	if (argc != 2) {
		fprintf (stderr, "usage: %s <N>\n", argv[0]);
		return 1;
	}

	int N = atoi (argv[1]);

	int sum = 0;

	/*
	 * The searched for triangles will consist of 2 right angled triangles (imagine a split via the elevation against the base)
	 * They must necessarily be given by primitive Pythagorean triplets as the larger triplets would not give almost-equilateral triangles
	 *
	 * The longest side of the triplet will be the leg of the triangle and one of the shorter sides will be half a base
	 * Take the Euclidean algorithm for generating Pythagorean triplets and calculate the difference between the sides in terms of m, n
	 * The difference has to be equal to +/- 1
	 * This gives us the 4 quadratic equations solved in the loop for all possible n
	 */

	for (int n = 1;; n++) {
		int n2 = n * n;

		int m = 0;
		long perimeter = 0;

		if (get_perimeter (n + 1, n) >= N)
			break;

		if ((m = get_m (3 * n2, 0, 1)) == -1)
			m = get_m (3 * n2, 0, -1);

		if (m > 0) {
			perimeter = get_perimeter (m, n);

			if (perimeter < N)
				sum += perimeter;
		}

		if ((m = get_m (1, -4 * n, n2 + 1)) == -1)
			m = get_m (1, -4 * n, n2 - 1);

		if (m > 0) {
			perimeter = get_perimeter (m, n);

			if (perimeter < N)
				sum += perimeter;
		}
	}

	printf ("%d\n", sum);

	return 0;
}

/*
 * Returns the perimeter of an isosceles triangle equal to 2 right angled triangles
 * with side lengths given by a primite Pythagorean triplet generated by the Euclidean algorithm
 * with seeds m and n
 *
 * Two such triangles exist, but only when the right angled triangles are joined by their longer leg
 * can the almost-equilateral criterion be met
 */
static long get_perimeter (int m, int n) {
	int sides[3];

	if (!euclid_pythagorean_triple (m, n, sides, sides + 1, sides + 2))
		return 0;

	long longest_side = sides[2];
	long shortes_side = MIN (sides[0], sides[1]);

	return 2 * longest_side + 2 * shortes_side;
}

/*
 * Returns the larger root of the quadratic equation a*x^2 + bx + c = 0
 * if integral, otherwise returns -1
 *
 * Not generally applicable, in this problem, we know one root will be positive and the other negative
 */
static int get_m (int a, int b, int c) {
	if (b == 0)
		return integer_sqrt (a + c);
	else {
		int d2 = b * b - 4 * a * c;
		int d = 0;

		if ((d = integer_sqrt (d2)) != -1) {
			if (d % 2 == 0)
				return (-b + d) / 2;
		}

		return -1;
	}
}
